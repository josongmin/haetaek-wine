// controllers/external_wine_search.controller.js
import fetch from 'node-fetch';

// 메모리 캐시 (간단한 구현)
const searchCache = new Map();
const CACHE_TTL = 7 * 24 * 60 * 60 * 1000; // 7일

/**
 * 한글이 포함되어 있는지 확인
 */
function containsKorean(text) {
  return /[가-힣]/.test(text);
}

/**
 * 한글 키워드 정규화 (띄어쓰기, 외래어 표기 통일)
 */
function normalizeKoreanKeyword(keyword) {
  if (!keyword) return '';
  
  return keyword
    .replace(/\s+/g, ' ')           // 여러 공백을 하나로
    .replace(/샤또/g, '샤토')       // 통일된 표기
    .replace(/샤또/g, '샤토')
    .replace(/도메인/g, '도멘')
    .replace(/까베르네/g, '카베르네')
    .replace(/쇼비뇽/g, '소비뇽')
    .replace(/쏘비뇽/g, '소비뇽')
    .replace(/삐노/g, '피노')
    .replace(/쉬라/g, '시라')
    .replace(/메를로/g, '메를로')
    .trim()
    .toLowerCase();
}

/**
 * 안전한 URL 디코딩 (잘못된 바이트 시퀀스 처리)
 */
function safeDecodeURIComponent(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (e) {
    // 잘못된 인코딩이 있는 경우, 부분적으로 디코딩 시도
    try {
      // 정규식으로 유효한 인코딩만 디코딩
      return str.replace(/%([0-9A-F]{2})/gi, (match, hex) => {
        try {
          return decodeURIComponent(match);
        } catch {
          return match; // 디코딩 실패 시 원본 반환
        }
      }).replace(/\+/g, ' ');
    } catch {
      // 모든 디코딩 실패 시 + 만 공백으로 변환
      return str.replace(/\+/g, ' ');
    }
  }
}

/**
 * 캐시 키 생성 (정규화된 키워드 사용)
 */
function getCacheKey(keyword) {
  return normalizeKoreanKeyword(keyword);
}

/**
 * 캐시에서 검색 결과 조회
 */
function getCachedResult(keyword) {
  const cacheKey = getCacheKey(keyword);
  const cached = searchCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  return null;
}

/**
 * 검색 결과를 캐시에 저장
 */
function setCachedResult(keyword, wines) {
  const cacheKey = getCacheKey(keyword);
  searchCache.set(cacheKey, {
    data: wines,
    timestamp: Date.now()
  });
}

/**
 * 캐시에서 특정 키워드 삭제
 */
function deleteCachedResult(keyword) {
  const cacheKey = getCacheKey(keyword);
  searchCache.delete(cacheKey);
  console.log(`캐시 삭제: ${keyword} (정규화된 키: ${cacheKey})`);
}

/**
 * 하드코딩된 포도품종 목록 (클라이언트의 grapeOptions와 동일)
 */
const GRAPE_OPTIONS = [
  "Abouriou", "Abrusco", "Aglianico", "Airen", "Albarino", "Alicante Bouschet",
  "Aligote", "Ansonica", "Aragonez", "Arneis", "Baga", "Barbera", "Biancame",
  "Bianchello", "Bical", "Bonarda", "Bourboulenc", "Brachetto", "Cabernet Franc",
  "Cabernet Sauvignon", "Caino Blanco", "Canaiolo", "Cannonau", "Carignan",
  "Carmenere", "Carricante", "Charbono", "Chardonnay", "Chenin Blanc", "Cinsault",
  "Clairette", "Cortese", "Corvina", "Corvinone", "Counoise", "Dolcetto", "Frappato",
  "Freisa", "Friulano", "Furmint", "Gamay", "Garganega", "Garnacha", "Garnacha tinta",
  "Gavi", "Gewurztraminer", "Glera", "Graciano", "Grenache", "Grenache Blanc",
  "Grenache Gris", "Gringet", "Grolleau", "Grolleau Gris", "Gros Manseng",
  "Gruner Veltliner", "Insolia", "Lambrusco", "Loureiro", "Macabeo", "Macabeu",
  "Malbec", "Malvasia", "Mansengs", "Maria Gomes", "Marsanne", "Mataro", "Mazuelo",
  "Melon de Bourgogne", "Mencia", "Merlot", "Molinara", "Monastrell", "Montepulciano",
  "Moscato Bianco", "Mourvedre", "Muscat Blanc", "Muscat Canelli", "Muscat of Alexandria",
  "Nebbiolo", "Negrette", "Negroamaro", "Nerello Cappuccio", "Nerello Mascalese",
  "Nero d'Avola", "Ortrugo", "Oseleta", "Parellada", "Pecorino", "Perricone",
  "Petit Courbu", "Petit Manseng", "Petit Verdot", "Petite Sirah", "Pinot Auxerrois",
  "Pinot Blanc", "Pinot Grigio", "Pinot Gris", "Pinot Meunier", "Pinot Noir", "Pinotage",
  "Poulsard", "Pugnitello", "Primitivo", "Riesling", "Rondinella", "Roussanne",
  "Sauvignon Blanc", "Savagnin", "Semillon", "Shiraz", "Silvaner", "Sousao",
  "Susumaniello", "Syrah", "Sangiovese", "Tannat", "Tempranillo", "Terret Blanc",
  "Timorasso", "Tinta de toro", "Tinta Roriz", "Torrontes", "Trebbiano", "Trousseau",
  "Ugni Blanc", "Veneto", "Verdejo", "Verdicchio", "Vermentino (Rolle)", "Viognier",
  "Xarel-lo", "Zinfandel", "Zweigelt"
];

/**
 * 포도품종 매핑 함수
 * API에서 받은 포도품종을 하드코딩된 목록과 매칭
 */
function mapGrapeVarieties(grapeVarieties) {
  if (!Array.isArray(grapeVarieties) || grapeVarieties.length === 0) {
    return [];
  }

  const mapped = [];

  for (const grape of grapeVarieties) {
    if (!grape || typeof grape !== 'string') continue;
    
    const grapeLower = grape.trim().toLowerCase();
    
    // 정확히 일치하는 경우
    const exactMatch = GRAPE_OPTIONS.find(g => g.toLowerCase() === grapeLower);
    if (exactMatch) {
      mapped.push(exactMatch);
      continue;
    }

    // 부분 일치 검색 (포함 관계)
    const partialMatch = GRAPE_OPTIONS.find(g => {
      const gLower = g.toLowerCase();
      return gLower.includes(grapeLower) || grapeLower.includes(gLower);
    });
    
    if (partialMatch) {
      mapped.push(partialMatch);
      continue;
    }

    // 매칭되지 않으면 원본 유지 (나중에 수동으로 처리 가능)
    mapped.push(grape.trim());
  }

  // 중복 제거
  return [...new Set(mapped)];
}

/**
 * 와인 이름 제안 API
 */
export const keywordSuggestion = async (req, res) => {
  try {
    let keyword = req.query.keyword || req.body.keyword;

    console.log('[keywordSuggestion] 원본 키워드:', keyword);
    console.log('[keywordSuggestion] 요청 정보:', {
      method: req.method,
      url: req.url,
      query: req.query,
      body: req.body
    });

    if (!keyword || typeof keyword !== 'string') {
      return res.status(400).json({ ok: false, error: 'keyword is required' });
    }

    // URL 디코딩 처리 (안전하게)
    try {
      keyword = safeDecodeURIComponent(keyword);
      console.log('[keywordSuggestion] 디코딩된 키워드:', keyword);
    } catch (decodeError) {
      // 디코딩 실패 시 + 만 공백으로 변환하고 원본 사용
      console.warn('[keywordSuggestion] 키워드 디코딩 실패, 원본 사용:', keyword, decodeError.message);
      keyword = keyword.replace(/\+/g, ' ');
    }

    // 키워드 정리 (공백 제거 및 정규화)
    keyword = keyword.trim().replace(/\s+/g, ' ');

    // 빈 키워드 체크
    if (!keyword || keyword.length === 0) {
      return res.status(400).json({ ok: false, error: 'keyword cannot be empty' });
    }

    console.log('[keywordSuggestion] 최종 키워드:', keyword);
    
    // 한글 키워드 정규화 (검색용)
    const normalizedKeyword = normalizeKoreanKeyword(keyword);
    console.log('[keywordSuggestion] 정규화된 키워드:', normalizedKeyword);

    // 한글이 없으면 빈 배열 반환
    if (!containsKorean(keyword)) {
      return res.json({ ok: true, wines: [] });
    }

    // 캐시에서 먼저 확인
    const cachedResult = getCachedResult(keyword);
    if (cachedResult) {
      console.log(`캐시에서 검색 결과 반환: ${keyword}`);
      return res.json({ ok: true, wines: cachedResult, fromCache: true });
    }

    const geminiApiKey = process.env.GEMINI_API_KEY;

    const prompt = `당신은 한국의 와인 전문가입니다.

키워드: "${keyword}"
정규화된 키워드: "${normalizedKeyword}"

## 임무
실제 한국에서 판매되거나 알려진 와인만 반환하세요.
추측하거나 생성하지 마세요. 확실히 아는 와인만 포함하세요.

## 한글 키워드 처리 규칙
1. 띄어쓰기 무시: "샤또라피트" = "샤또 라피트"
2. 외래어 표기: "샤또" = "샤토", "도메인" = "도멘", "까베르네" = "카베르네"
3. 생략형 확장: "DRC" → "도멘 드 라 로마네 꽁띠"
4. 부분 매칭: "오 브리옹" → "샤또 오 브리옹"

## 검색 우선순위
1. 정확한 이름 매칭 (2-3개)
2. 생산자명 매칭 (같은 생산자의 다른 와인 2-3개)
3. 포도 품종 + 지역 조합 (2-3개)
4. 유사 발음/표기 (2-3개)

총 10-15개의 다양한 와인을 제공하세요.

## 출력 형식
{
  "wines": [
    {
      "kr_name": "정확한 한글명",
      "en_name": "정확한 영어명",
      "fr_name": null,
      "dutch_name": null,
      "thumbnail_url": null,
      "vintage": null,
      "confidence": "high"
    }
  ]
}

## confidence 필드
- "high": 확실히 아는 와인
- "medium": 알고 있지만 일부 정보 불확실
- "low": 존재는 확인되나 세부정보 불확실

## 엄격한 규칙
✅ 실제 존재하는 와인만 반환
✅ 확실하지 않으면 confidence 표시
✅ 모르는 필드는 null 사용 (추측 금지)
✅ 순수 JSON만 반환 (코드블록, 마크다운, 설명 금지)
✅ kr_name과 en_name은 필수 (null 불가)
❌ 추측하지 마세요
❌ 이미지 URL 지어내지 마세요
❌ 가격 정보 지어내지 마세요
❌ \`\`\`json 같은 코드 블록 사용 금지`;

    // Gemini API 호출 (속도 최적화 설정)
    console.log(`[keywordSuggestion] 키워드: "${keyword}", Gemini API 호출 시작`);
    const startTime = Date.now();
    let response;
    try {
      response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${geminiApiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.1,           // 더 낮춰서 환각 감소 및 일관성 향상
            maxOutputTokens: 2500,      // 10-15개 와인에 충분한 토큰
            topP: 0.7,                  // 더 보수적으로 (환각 감소)
            topK: 20,                   // 후보 토큰 제한 (정확도 향상)
            candidateCount: 1,          // 1개 후보만 생성
          }
        }),
      });
    } catch (fetchError) {
      console.error('[keywordSuggestion] Gemini API fetch 실패:', fetchError);
      throw new Error(`Gemini API 네트워크 오류: ${fetchError.message}`);
    }

    if (!response.ok) {
      let errorData = {};
      try {
        const errorText = await response.text();
        errorData = JSON.parse(errorText);
      } catch (parseError) {
        console.error('[keywordSuggestion] 에러 응답 파싱 실패:', parseError);
      }
      const errorMessage = errorData.error?.message || `Gemini API error: ${response.status} ${response.statusText}`;
      console.error('[keywordSuggestion] Gemini API 오류:', errorMessage);
      throw new Error(errorMessage);
    }

    let data;
    try {
      data = await response.json();
    } catch (jsonError) {
      console.error('[keywordSuggestion] Gemini API 응답 JSON 파싱 실패:', jsonError);
      throw new Error(`Gemini API 응답 파싱 오류: ${jsonError.message}`);
    }

    // Gemini 응답에서 텍스트 추출
    const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!responseText) {
      console.error('[keywordSuggestion] Gemini API 응답에 텍스트 없음:', JSON.stringify(data, null, 2));
      throw new Error('No response text from Gemini');
    }

    // JSON 파싱 시도
    let wines = [];
    try {
      // JSON 코드 블록 제거 (강화된 로직)
      let jsonText = responseText.trim();
      
      // 코드 블록 제거 (여러 패턴 지원)
      if (jsonText.includes('```')) {
        // 패턴 1: ```json ... ```
        jsonText = jsonText.replace(/```json\s*/gi, '');
        // 패턴 2: ``` ... ```
        jsonText = jsonText.replace(/```\s*/g, '');
      }
      
      // 앞뒤 공백 및 줄바꿈 제거
      jsonText = jsonText.trim();
      
      // JSON 시작 찾기 (첫 번째 { 또는 [)
      const jsonStartMatch = jsonText.match(/[{\[]/);
      if (jsonStartMatch) {
        const startIdx = jsonStartMatch.index;
        jsonText = jsonText.substring(startIdx);
        
        // JSON 끝 찾기 (마지막 } 또는 ])
        const lastBraceIdx = jsonText.lastIndexOf('}');
        const lastBracketIdx = jsonText.lastIndexOf(']');
        const endIdx = Math.max(lastBraceIdx, lastBracketIdx);
        if (endIdx !== -1) {
          jsonText = jsonText.substring(0, endIdx + 1);
        }
      }
      
      const parsed = JSON.parse(jsonText);
      wines = parsed.wines || [];
      
      // 파싱된 결과 검증
      if (!Array.isArray(wines)) {
        console.error('[keywordSuggestion] wines가 배열이 아님:', typeof wines, wines);
        wines = [];
      } else {
        // 최소한의 검증만 수행 (kr_name과 en_name이 모두 없는 경우만 제외)
        const originalCount = wines.length;
        wines = wines.filter(wine => {
          if (!wine.kr_name && !wine.en_name) {
            console.warn('[keywordSuggestion] kr_name과 en_name이 모두 없는 와인 제외:', wine);
            return false;
          }
          return true;
        });
        
        if (originalCount !== wines.length) {
          console.log(`[keywordSuggestion] 유효하지 않은 와인 ${originalCount - wines.length}개 필터링됨`);
        }
      }
      
      // confidence 필드 처리 및 통계
      const confidenceStats = {
        high: wines.filter(w => w.confidence === 'high').length,
        medium: wines.filter(w => w.confidence === 'medium').length,
        low: wines.filter(w => w.confidence === 'low').length,
        undefined: wines.filter(w => !w.confidence).length,
      };
      
      console.log(`[keywordSuggestion] 검색 결과: 총 ${wines.length}개`);
      console.log(`[keywordSuggestion] Confidence 분포 - high: ${confidenceStats.high}, medium: ${confidenceStats.medium}, low: ${confidenceStats.low}, undefined: ${confidenceStats.undefined}`);
      
      // 결과가 너무 적으면 경고
      if (wines.length === 0) {
        console.warn('[keywordSuggestion] 검색 결과가 없습니다. Gemini 응답:', responseText.substring(0, 500));
      } else if (wines.length === 1) {
        console.warn('[keywordSuggestion] 검색 결과가 1개만 반환됨. Gemini 응답:', responseText.substring(0, 500));
      }
      
      // confidence가 없는 와인은 medium으로 설정
      wines = wines.map(wine => ({
        ...wine,
        confidence: wine.confidence || 'medium'
      }));
      
      // confidence가 low인 와인 경고 (필터링하지는 않음)
      const lowConfidenceWines = wines.filter(w => w.confidence === 'low');
      if (lowConfidenceWines.length > 0) {
        console.log(`⚠️ 낮은 확신도 와인 ${lowConfidenceWines.length}개:`, lowConfidenceWines.map(w => w.kr_name));
      }
    } catch (parseError) {
      // JSON 파싱 실패 시 빈 배열 반환
      console.error('[keywordSuggestion] JSON 파싱 실패:', parseError.message);
      console.error('[keywordSuggestion] 파싱 에러 스택:', parseError.stack);
      console.error('[keywordSuggestion] 응답 텍스트 전체:', responseText);
      console.error('[keywordSuggestion] 정리된 JSON 텍스트:', jsonText);
      wines = [];
    }

    // 검색 결과를 캐시에 저장
    if (wines.length > 0) {
      setCachedResult(keyword, wines);
      const elapsedTime = Date.now() - startTime;
      console.log(`검색 결과 캐시에 저장: ${keyword} (${wines.length}개, ${elapsedTime}ms)`);
    }

    res.json({ ok: true, wines, fromCache: false });
  } catch (e) {
    console.error('[keywordSuggestion] 와인 이름 제안 API 호출 실패:', e.message);
    console.error('[keywordSuggestion] 에러 스택:', e.stack);
    console.error('[keywordSuggestion] 요청 정보:', {
      method: req.method,
      url: req.url,
      query: req.query,
      body: req.body
    });
    res.status(500).json({ 
      ok: false, 
      error: e.message || '서버 오류가 발생했습니다.',
      ...(process.env.NODE_ENV === 'development' && { stack: e.stack })
    });
  }
};

export const getWineDetails = async (req, res) => {
  try {
    const { wine } = req.body;
    
    if (!wine) {
      return res.status(400).json({ success: false, message: '와인 정보가 필요합니다.' });
    }

    // 영어 이름과 필요한 정보를 기반으로 검색어 구성
    const searchQuery = [
      wine.en_name,
      wine.kr_name,
      wine.vintage ? `${wine.vintage}` : null,
      wine.fr_name
    ].filter(Boolean).join(' ');

    if (!searchQuery.trim()) {
      return res.status(400).json({ success: false, message: '검색할 와인 이름이 필요합니다.' });
    }

    // Perplexity API 호출
    // Perplexity API 키는 환경변수나 설정에서 가져와야 함
    const perplexityApiKey = process.env.PERPLEXITY_API_KEY;
    
    const prompt = `다음 와인에 대한 상세 정보를 JSON 형식으로 제공해주세요.

와인 정보:
- 영어 이름: ${wine.en_name || 'N/A'}
- 한국어 이름: ${wine.kr_name || 'N/A'}
- 프랑스어 이름: ${wine.fr_name || 'N/A'}
- 빈티지: ${wine.vintage || 'N/A'}

**중요: 검색 우선순위**
1. **최우선**: Wine-Searcher (wine-searcher.com) - 와인 가격 비교, 상세 정보, 이미지
2. 기타 해외 와인 전문 사이트 (이미지 우선):
   - Wine.com
   - Wine Spectator (winespectator.com)
   - Decanter (decanter.com)
   - Robert Parker (robertparker.com)
   - Jancis Robinson (jancisrobinson.com)
   - Wine Enthusiast (wineenthusiast.com)
   - CellarTracker (cellartracker.com)
3. **참고**: Vivino는 접근 제한이 있어 이미지 URL을 제공하지 마세요

**검색 전략:**
- 먼저 Wine-Searcher에서 와인을 검색하세요
- Wine-Searcher의 정보와 이미지를 최우선으로 사용하세요
- 이미지는 Wine-Searcher, Wine.com, Wine Spectator 등 접근 가능한 사이트에서 가져오세요
- Vivino는 평점 정보만 참고하고, 이미지 URL은 제공하지 마세요
- 평점, 가격, 리뷰 정보가 있다면 반드시 포함하세요

다음 정보를 포함한 JSON을 반환해주세요:
{
  "thumbnail_url": "와인 썸네일 이미지 URL (Wine-Searcher 우선, 접근 가능한 사이트에서)",
  "sources": [
    {
      "site_name": "사이트 이름 (Wine-Searcher 우선)",
      "url": "사이트 URL",
      "image_url": "해당 사이트에서 찾은 와인 이미지 URL (Wine-Searcher, Wine.com 등 접근 가능한 사이트 우선, Vivino는 제외)"
    }
  ],
  "rating": {
    "score": 4.5,
    "max_score": 5.0,
    "source": "평점 출처 (Vivino 정보는 참고만 하고 이미지는 제외)"
  },
  "description": "와인 설명",
  "region": "생산 지역",
  "grape_varieties": ["포도 품종1", "포도 품종2"],
  "winery": "와이너리 이름",
  "alcohol_content": "알코올 도수",
  "tasting_notes": "테이스팅 노트",
  "food_pairing": ["페어링 음식1", "페어링 음식2"],
  "vintage": "${wine.vintage || ''}",
  "price_range": "가격 범위 (Wine-Searcher에서 가져온 정보 우선)"
}

중요:
- 실제 검색 결과를 기반으로 정확한 정보를 제공하세요
- Wine-Searcher를 최우선으로 검색하세요
- 썸네일 이미지는 Wine-Searcher, Wine.com, Wine Spectator 등 접근 가능한 사이트에서 가져오세요
- Vivino는 평점 정보만 참고하고, 이미지 URL은 제공하지 마세요 (접근 제한 때문)
- sources 배열에는 정보를 찾은 사이트들을 포함하세요 (Wine-Searcher 우선)
- 각 source 객체에는 site_name, url, image_url을 포함하세요
- image_url은 Wine-Searcher, Wine.com 등 접근 가능한 사이트의 와인 이미지 URL입니다 (Vivino 제외)
- rating이 있는 경우 제공하세요 (Vivino 평점은 참고용으로만 사용)
- 정보가 없는 경우 null 또는 빈 배열을 사용하세요
- JSON만 반환하고 다른 텍스트는 포함하지 마세요`;

    const perplexityResponse = await fetch('https://api.perplexity.ai/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${perplexityApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'sonar',
        messages: [
          {
            role: 'system',
            content: 'You are a helpful assistant that provides wine information in JSON format.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.2,
        max_tokens: 2000
      }),
    });

    if (!perplexityResponse.ok) {
      const errorData = await perplexityResponse.json().catch(() => ({}));
      console.error('Perplexity API 오류:', errorData);
      throw new Error(`Perplexity API error: ${perplexityResponse.status}`);
    }

    const perplexityData = await perplexityResponse.json();
    const responseText = perplexityData.choices?.[0]?.message?.content;

    if (!responseText) {
      throw new Error('Perplexity API에서 응답을 받지 못했습니다.');
    }

    // JSON 파싱 시도
    let wineDetails = {};
    try {
      // JSON 코드 블록 제거
      let jsonText = responseText.trim();
      if (jsonText.includes('```')) {
        const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
        if (jsonBlockMatch && jsonBlockMatch[1]) {
          jsonText = jsonBlockMatch[1].trim();
        }
      }
      
      wineDetails = JSON.parse(jsonText);
    } catch (parseError) {
      console.error('JSON 파싱 실패:', parseError);
      console.error('응답 텍스트:', responseText.substring(0, 500));
      // 파싱 실패 시 기본 구조 반환
      wineDetails = {
        thumbnail_url: wine.thumbnail_url || null,
        sources: [],
        rating: null,
        description: responseText.substring(0, 500),
        region: null,
        grape_varieties: [],
        winery: null,
        alcohol_content: null,
        tasting_notes: null,
        food_pairing: [],
        vintage: wine.vintage || null,
        price_range: null
      };
    }

    // 포도품종 매핑
    const mappedGrapeVarieties = mapGrapeVarieties(wineDetails.grape_varieties || []);

    // 검색 필드 생성 (Gemini API 호출)
    let searchField = '';
    try {
      const geminiApiKey = process.env.GEMINI_API_KEY;
      
      // 와인 객체 구성
      const wineObject = {
        original_en: wine.en_name || '',
        original_ko: wine.kr_name || '',
        normalized_en: wine.en_name ? [wine.en_name.toLowerCase().replace(/\s+/g, ' ').trim()] : [],
        normalized_ko: wine.kr_name ? [wine.kr_name.replace(/\s+/g, ' ').trim()] : [],
        variants_en: wine.fr_name ? [wine.fr_name] : [],
        variants_ko: wine.dutch_name ? [wine.dutch_name] : []
      };

      const searchFieldPrompt = `#와인검색어 조립용 프롬프트

You are a very senior sommelier and also an expert in search relevance and recall optimization.

Goal:

Given a single wine object, you must generate keyword arrays that maximize recall for user search queries in both English and Korean. Users will type many kinds of noisy queries (missing words, spacing issues, misspellings, partial names, etc.), and we want to cover as many realistic patterns as possible without adding random or unrelated terms.

Input format:

You will receive a JSON object with this structure:

{
  "original_en": "string",        // Original English label
  "original_ko": "string",        // Original Korean label

  "normalized_en": [ "string", ... ],  // Lowercased / normalized English forms
  "normalized_ko": [ "string", ... ],  // Normalized Korean forms

  "variants_en": [ "string", ... ],    // Known English variants & misspellings
  "variants_ko": [ "string", ... ]     // Known Korean variants & misspellings
}

Task:

1. Read and understand the wine name and all its components:

   - Producer / estate

   - Village / vineyard

   - Grape variety

   - Style / sweetness level (e.g., Spätlese, Kabinett, etc.)

   - Special terms (e.g., Versteigerung, Grosses Gewächs, Reserve, etc.)

   - Important Korean transliterations and typical Korean typos

2. Generate up to 10 keyword arrays.

   Each array is a list of strings that represent a coherent search intent pattern.

   Examples of intent patterns (for guidance, not exhaustive):

   - Full official name (EN + KO)

   - Very strict normalized full name (no spaces)

   - Vineyard + grape + style (+ special term)

   - Grape + style (+ special term)

   - Producer + vineyard

   - Producer + grape / style

   - Vineyard / village only

   - Style / special term only (for users who remember only "Riesling Spätlese", etc.)

   - Korean-focused versions of the above (including common typos and spacing variants)

3. Use all available fields:

   - Use \`original_en\`, \`original_ko\` as high-precision full names.

   - Use \`normalized_en\`, \`normalized_ko\` as tighter, normalized variants.

   - Use \`variants_en\`, \`variants_ko\` to introduce realistic misspellings and short forms.

   - Prefer realistic and useful combinations rather than generating every possible permutation.

4. Prioritization:

   - Arrays should be ordered from most precise / high-intent to more generic / fuzzy.

   - Within an array, list the most correct/canonical forms first, then misspellings or looser forms.

   - Do NOT add terms that are not clearly derived from the input.

Output format:

You MUST respond with a single JSON object, and nothing else. No explanations, no comments, no surrounding text.

The JSON schema must be:

{
  "keyword_arrays": [
    ["string", "string", ...],
    ["string", "string", ...],
    ...
  ]
}

Rules:

- Return at most 10 arrays in "keyword_arrays".

- Each inner array must have at least 2 strings, unless it is a very special high-precision case.

- All strings must be plain text (no comments, no inline annotations).

- The JSON must be syntactically valid: no trailing commas, no comments.

Now process this wine object and return only the JSON:

${JSON.stringify(wineObject, null, 2)}`;

      const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${geminiApiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: searchFieldPrompt
            }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 2000,    // 검색 필드는 더 작아도 충분
            topP: 0.8,
            topK: 40,
            candidateCount: 1,
          }
        }),
      });

      if (geminiResponse.ok) {
        const geminiData = await geminiResponse.json();
        const geminiText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (geminiText) {
          // JSON 파싱 시도
          let jsonText = geminiText.trim();
          if (jsonText.includes('```')) {
            const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch && jsonBlockMatch[1]) {
              jsonText = jsonBlockMatch[1].trim();
            }
          }
          
          try {
            const parsed = JSON.parse(jsonText);
            if (parsed.keyword_arrays && Array.isArray(parsed.keyword_arrays)) {
              // 키워드 배열들을 하나의 문자열로 합치기 (각 배열은 줄바꿈으로 구분)
              searchField = parsed.keyword_arrays
                .map(arr => Array.isArray(arr) ? arr.join(' ') : '')
                .filter(s => s.length > 0)
                .join('\n');
            }
          } catch (parseError) {
            console.error('검색 필드 JSON 파싱 실패:', parseError);
            // 파싱 실패 시 빈 문자열 유지
          }
        }
      } else {
        console.error('Gemini API 검색 필드 생성 실패:', geminiResponse.status);
      }
    } catch (searchFieldError) {
      console.error('검색 필드 생성 중 오류:', searchFieldError);
      // 검색 필드 생성 실패해도 계속 진행
    }

    // 기본 와인 정보와 병합
    const finalDetails = {
      kr_name: wine.kr_name || null,
      en_name: wine.en_name || null,
      fr_name: wine.fr_name || null,
      dutch_name: wine.dutch_name || null,
      thumbnail_url: wineDetails.thumbnail_url || wine.thumbnail_url || null,
      sources: wineDetails.sources || [],
      rating: wineDetails.rating || null,
      description: wineDetails.description || null,
      region: wineDetails.region || null,
      grape_varieties: mappedGrapeVarieties,
      winery: wineDetails.winery || null,
      alcohol_content: wineDetails.alcohol_content || null,
      tasting_notes: wineDetails.tasting_notes || null,
      food_pairing: wineDetails.food_pairing || [],
      vintage: wineDetails.vintage || wine.vintage || null,
      price_range: wineDetails.price_range || null,
      searchField: searchField || null
    };
    
    res.json({ success: true, wineDetails: finalDetails });
  } catch (err) {
    console.error('와인 상세 정보 조회 실패:', err);
    res.status(500).json({ success: false, message: err.message || '서버 오류' });
  }
};

/**
 * 검색 캐시 삭제 API
 */
export const deleteCache = async (req, res) => {
  try {
    const keyword = req.query.keyword || req.body.keyword;

    if (!keyword || typeof keyword !== 'string') {
      return res.status(400).json({ ok: false, error: 'keyword is required' });
    }

    deleteCachedResult(keyword);
    res.json({ ok: true, message: '캐시가 삭제되었습니다.' });
  } catch (e) {
    console.error('캐시 삭제 실패:', e);
    res.status(500).json({ ok: false, error: e.message });
  }
};

/**
 * Candidate들을 Perplexity API로 동시 검색하고 스코어링하여 정렬
 * POST /external_wine_search/search_candidates_with_perplexity
 */
export const searchCandidatesWithPerplexity = async (req, res) => {
  try {
    const { candidates, original_ko } = req.body;
    
    if (!candidates || !Array.isArray(candidates) || candidates.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'candidates 배열이 필요합니다.' 
      });
    }

    const perplexityApiKey = process.env.PERPLEXITY_API_KEY;
    
    console.log(`[searchCandidatesWithPerplexity] 시작 - candidates: ${candidates.length}개, original_ko: ${original_ko || 'N/A'}`);
    
    // 모든 candidate를 동시에 검색
    const searchPromises = candidates.map(async (candidate, index) => {
      try {
        console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1}/${candidates.length} 검색 시작: "${candidate}"`);
        
        const prompt = `다음 와인 이름으로 검색하여 와인 정보를 JSON 형식으로 제공해주세요.

와인 이름: ${candidate}
${original_ko ? `원본 한국어 이름: ${original_ko}` : ''}

**중요: 검색 우선순위**
1. **최우선**: Wine-Searcher (wine-searcher.com) - 와인 가격 비교, 상세 정보, 이미지
2. 기타 해외 와인 전문 사이트:
   - Wine.com
   - Wine Spectator (winespectator.com)
   - Decanter (decanter.com)
   - Robert Parker (robertparker.com)
   - Vivino (vivino.com)
   - CellarTracker (cellartracker.com)

다음 정보를 포함한 JSON을 반환해주세요:
{
  "wine_name": "정확한 와인 이름",
  "thumbnail_url": "와인 썸네일 이미지 URL",
  "sources": [
    {
      "site_name": "사이트 이름",
      "url": "사이트 URL",
      "image_url": "해당 사이트의 와인 이미지 URL"
    }
  ],
  "rating": {
    "score": 4.5,
    "max_score": 5.0,
    "source": "평점 출처"
  },
  "price_range": "가격 범위 (예: $50-80)",
  "description": "와인 설명",
  "region": "생산 지역",
  "grape_varieties": ["포도 품종1", "포도 품종2"],
  "winery": "와이너리 이름",
  "vintage": "빈티지",
  "relevance_score": 0.95,
  "match_confidence": "high"
}

중요:
- relevance_score는 검색된 와인이 입력된 이름과 얼마나 일치하는지 0.0-1.0 사이의 점수로 제공하세요
- match_confidence는 "high", "medium", "low" 중 하나로 제공하세요
- 실제 검색 결과를 기반으로 정확한 정보를 제공하세요
- 정보가 없는 경우 null 또는 빈 배열을 사용하세요
- JSON만 반환하고 다른 텍스트는 포함하지 마세요`;

        const requestBody = {
          model: 'sonar',
          messages: [
            {
              role: 'system',
              content: 'You are a helpful assistant that provides wine information in JSON format.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.2,
          max_tokens: 2000
        };
        
        console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1} API 호출 시작`);
        const startTime = Date.now();
        
        const perplexityResponse = await fetch('https://api.perplexity.ai/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${perplexityApiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        });
        
        const elapsedTime = Date.now() - startTime;
        console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1} API 응답 수신 (${elapsedTime}ms) - Status: ${perplexityResponse.status}`);

        if (!perplexityResponse.ok) {
          const errorText = await perplexityResponse.text().catch(() => '');
          const errorPreview = errorText.length > 300 ? errorText.substring(0, 300) + '...' : errorText;
          console.error(`[searchCandidatesWithPerplexity] Candidate ${index + 1} API 오류 (${perplexityResponse.status}):`, errorPreview);
          return {
            candidate,
            index,
            success: false,
            error: `API error: ${perplexityResponse.status}`
          };
        }

        const perplexityData = await perplexityResponse.json();
        const responseText = perplexityData.choices?.[0]?.message?.content;
        
        // 응답 로그 (너무 길면 자르기)
        const responsePreview = responseText ? 
          (responseText.length > 500 ? responseText.substring(0, 500) + '...' : responseText) : 
          'null';
        console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1} 응답 (${responseText?.length || 0}자):`, responsePreview);
        
        if (!responseText) {
          console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1} 응답 없음`);
          return {
            candidate,
            index,
            success: false,
            error: '응답 없음'
          };
        }

        // JSON 파싱
        let wineData = {};
        try {
          let jsonText = responseText.trim();
          
          // 코드 블록 제거
          if (jsonText.includes('```')) {
            const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch && jsonBlockMatch[1]) {
              jsonText = jsonBlockMatch[1].trim();
            }
          }
          
          // JSON 객체 시작/끝 찾기
          const firstBrace = jsonText.indexOf('{');
          const lastBrace = jsonText.lastIndexOf('}');
          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            jsonText = jsonText.substring(firstBrace, lastBrace + 1);
          }
          
          // 첫 번째 파싱 시도
          try {
            wineData = JSON.parse(jsonText);
          } catch (firstTryError) {
            // 파싱 실패 시, JSON 문자열 내부의 문제 수정 시도
            // 따옴표가 제대로 닫히지 않은 경우를 처리하기 위해
            // 여러 방법으로 시도
            
            // 방법 1: JSON 객체를 정규식으로 추출 (더 정교하게)
            const jsonObjectPattern = /\{(?:[^{}]|(?:\{[^{}]*\}))*\}/;
            const jsonMatch = jsonText.match(jsonObjectPattern);
            if (jsonMatch) {
              try {
                wineData = JSON.parse(jsonMatch[0]);
              } catch (secondTryError) {
                // 방법 2: 첫 번째 완전한 JSON 객체만 추출 시도
                let braceCount = 0;
                let startIdx = -1;
                let endIdx = -1;
                
                for (let i = 0; i < jsonText.length; i++) {
                  if (jsonText[i] === '{') {
                    if (startIdx === -1) startIdx = i;
                    braceCount++;
                  } else if (jsonText[i] === '}') {
                    braceCount--;
                    if (braceCount === 0 && startIdx !== -1) {
                      endIdx = i;
                      break;
                    }
                  }
                }
                
                if (startIdx !== -1 && endIdx !== -1) {
                  try {
                    wineData = JSON.parse(jsonText.substring(startIdx, endIdx + 1));
                  } catch (thirdTryError) {
                    // 모든 시도 실패
                    throw firstTryError;
                  }
                } else {
                  throw firstTryError;
                }
              }
            } else {
              throw firstTryError;
            }
          }
        } catch (parseError) {
          console.error(`JSON 파싱 실패 (candidate: ${candidate}):`, parseError.message);
          console.error(`응답 텍스트 (처음 1000자):`, responseText.substring(0, 1000));
          
          // 파싱 실패해도 기본 정보는 반환 (부분 성공으로 처리)
          return {
            candidate,
            index,
            success: true,
            data: {
              wine_name: candidate,
              thumbnail_url: null,
              sources: [],
              rating: null,
              price_range: null,
              description: null,
              region: null,
              grape_varieties: [],
              winery: null,
              vintage: null,
              relevance_score: 0.3, // 낮은 점수 (파싱 실패)
              match_confidence: 'low'
            }
          };
        }

        const resultData = {
          wine_name: wineData.wine_name || candidate,
          thumbnail_url: wineData.thumbnail_url || null,
          sources: wineData.sources || [],
          rating: wineData.rating || null,
          price_range: wineData.price_range || null,
          description: wineData.description || null,
          region: wineData.region || null,
          grape_varieties: wineData.grape_varieties || [],
          winery: wineData.winery || null,
          vintage: wineData.vintage || null,
          relevance_score: wineData.relevance_score || 0.5,
          match_confidence: wineData.match_confidence || 'medium'
        };
        
        console.log(`[searchCandidatesWithPerplexity] Candidate ${index + 1} 파싱 완료:`, {
          wine_name: resultData.wine_name,
          sources_count: resultData.sources?.length || 0,
          relevance_score: resultData.relevance_score,
          match_confidence: resultData.match_confidence
        });
        
        return {
          candidate,
          index,
          success: true,
          data: resultData
        };
      } catch (error) {
        console.error(`후보 "${candidate}" 검색 오류:`, error);
        return {
          candidate,
          index,
          success: false,
          error: error.message
        };
      }
    });

    const results = await Promise.all(searchPromises);
    
    console.log(`[searchCandidatesWithPerplexity] 모든 검색 완료 - 성공: ${results.filter(r => r.success).length}개, 실패: ${results.filter(r => !r.success).length}개`);
    
    // 공신력 있는 사이트 목록
    const trustedSites = [
      'vivino',
      'wine-searcher',
      'winesearcher',
      'cellartracker',
      'wine.com',
      'winespectator',
      'decanter',
      'robertparker',
      'jancisrobinson',
      'wineenthusiast'
    ];

    // 성공한 결과만 필터링하고 스코어링하여 정렬
    const successfulResults = results
      .filter(r => r.success && r.data)
      .map(r => {
        const data = r.data;
        // 공신력 있는 사이트가 sources에 있는지 확인
        const hasTrustedSite = data.sources?.some(source => {
          const siteName = (source.site_name || '').toLowerCase();
          return trustedSites.some(trusted => siteName.includes(trusted));
        });
        
        return {
          ...data,
          candidate: r.candidate,
          originalIndex: r.index,
          hasTrustedSite
        };
      })
      .sort((a, b) => {
        // 스코어링 로직:
        // 1. 공신력 있는 사이트 보너스 (50점)
        // 2. relevance_score (100점 만점)
        // 3. match_confidence (high: 10, medium: 5, low: 0)
        // 4. sources 수 (최대 10점)
        const scoreA = (a.hasTrustedSite ? 50 : 0) +
                      (a.relevance_score || 0) * 100 + 
                      (a.match_confidence === 'high' ? 10 : a.match_confidence === 'medium' ? 5 : 0) +
                      Math.min((a.sources?.length || 0), 10);
        const scoreB = (b.hasTrustedSite ? 50 : 0) +
                      (b.relevance_score || 0) * 100 + 
                      (b.match_confidence === 'high' ? 10 : b.match_confidence === 'medium' ? 5 : 0) +
                      Math.min((b.sources?.length || 0), 10);
        return scoreB - scoreA; // 내림차순 정렬
      });

    console.log(`[searchCandidatesWithPerplexity] 정렬 완료 - 최종 결과: ${successfulResults.length}개`);
    if (successfulResults.length > 0) {
      console.log(`[searchCandidatesWithPerplexity] 상위 3개 결과:`, successfulResults.slice(0, 3).map(r => ({
        wine_name: r.wine_name,
        relevance_score: r.relevance_score,
        match_confidence: r.match_confidence,
        hasTrustedSite: r.hasTrustedSite,
        sources_count: r.sources?.length || 0
      })));
    }

    res.json({
      success: true,
      results: successfulResults,
      total: successfulResults.length,
      failed: results.filter(r => !r.success).length
    });
  } catch (err) {
    console.error('Candidate 검색 실패:', err);
    res.status(500).json({ 
      success: false, 
      message: err.message || '서버 오류' 
    });
  }
};

/**
 * 구글 검색 결과에서 URL 추출 (Ver3)
 * POST /external_wine_search/search_single_candidate_v3
 */
// 신뢰할 수 있는 와인 도메인 목록
const TRUSTED_WINE_DOMAINS = [
  'vivino.com',
  'wine-searcher.com',
  'cellartracker.com',
  'decanter.com',
  'wineenthusiast.com',
];

/**
 * 와인 검색 쿼리 구성
 */
function buildWineQuery(wineName, withSites = false) {
  const base = `"${wineName}" wine`;
  // if (!withSites) return base;
  
  // const sitePart = TRUSTED_WINE_DOMAINS
  //   .map(d => `site:${d}`)
  //   .join(' OR ');
  
  // return `${base} (${sitePart})`;
  return base;
}

/**
 * 와인 검색 쿼리 구성 (search_metadata 사용)
 * 와인명, "wine", 주요 사이트 키워드 포함
 */
function buildWineQueryWithMetadata(searchMetadata, candidate) {
  // 쌍따옴표로 감싼 전체 이름 또는 기본 candidate
  const wineName = searchMetadata?.quoted_full_name || `"${candidate}"`;
  
  // 주요 사이트 키워드 추가
  const siteKeywords = TRUSTED_WINE_DOMAINS.map(domain => domain.split('.')[0]).join(' OR ');
  
  // 와인명, "wine", 주요 사이트 키워드 포함
  return `${wineName} "wine" ${siteKeywords}`;
}

/**
 * 와인명에서 생산자명 추출 (간단한 휴리스틱)
 */
function extractProducerName(candidate, searchMetadata) {
  // candidate에서 첫 번째 단어나 주요 단어 추출
  const words = candidate.split(/\s+/);
  if (words.length > 0) {
    // 첫 번째 단어가 생산자일 가능성이 높음
    return words[0].toLowerCase();
  }
  return '';
}

/**
 * 와인명에서 Cuvée 추출 (간단한 휴리스틱)
 */
function extractCuvee(candidate) {
  // "Vat 1", "Blood of Jupiter" 같은 특별한 이름 추출
  const cuveePatterns = [
    /vat\s+\d+/i,
    /blood\s+of\s+\w+/i,
    /museum\s+release/i,
    /reserve/i,
    /cuvée/i
  ];
  
  for (const pattern of cuveePatterns) {
    const match = candidate.match(pattern);
    if (match) {
      return match[0].toLowerCase();
    }
  }
  return '';
}

/**
 * 도메인 가중치 계산
 */
function domainWeight(url, producerName) {
  if (!url) return 5;
  
  const urlLower = url.toLowerCase();
  const domain = urlLower.match(/https?:\/\/(?:www\.)?([^\/]+)/)?.[1] || '';
  
  // 생산자 공식 사이트 체크
  if (producerName && domain.includes(producerName.toLowerCase())) {
    return 50;
  }
  
  // 주요 사이트 체크
  if (urlLower.includes('wine-searcher.com')) return 25;
  if (urlLower.includes('vivino.com')) return 25;
  if (urlLower.includes('cellartracker.com')) return 22;
  if (urlLower.includes('decanter.com')) return 20;
  if (urlLower.includes('wineenthusiast.com')) return 20;
  
  return 5;
}

/**
 * 결과 점수 계산
 */
function computeScore(result, context) {
  const { candidate, searchMetadata, producerName, cuvee, vintage } = context;
  
  // 전처리
  const title = (result.title || '').toLowerCase();
  const snippet = (result.snippet || '').toLowerCase();
  const text = `${title} ${snippet}`;
  const urlLower = (result.url || '').toLowerCase();
  
  // [1] 도메인 가중치
  const domainScore = domainWeight(result.url, producerName);
  
  // [2] 와인명 매칭
  let nameScore = 0;
  const candidateLower = candidate.toLowerCase();
  const candidateWords = candidateLower.split(/\s+/).filter(w => w.length > 2);
  
  // Exact match: candidate가 title에 거의 그대로 포함
  const nameExact = candidateWords.every(word => title.includes(word)) && 
                     title.includes(candidateWords[0]) && 
                     title.includes(candidateWords[candidateWords.length - 1]);
  
  // Partial match: producer + cuvée 조합
  const namePartial = !nameExact && producerName && cuvee &&
                       title.includes(producerName.toLowerCase()) &&
                       title.includes(cuvee.toLowerCase());
  
  if (nameExact) {
    nameScore = 30;
  } else if (namePartial) {
    nameScore = 18;
  } else {
    nameScore = 0;
  }
  
  // [3] 생산자명 매칭
  let producerScore = 0;
  if (producerName && (title.includes(producerName.toLowerCase()) || 
                       snippet.includes(producerName.toLowerCase()) || 
                       urlLower.includes(producerName.toLowerCase()))) {
    producerScore = 10;
  }
  
  // [4] 빈티지 매칭
  let vintageScore = 0;
  if (vintage && text.includes(vintage)) {
    vintageScore = 8;
  }
  
  // [5] 메타(지역/품종) 매칭
  let metaScore = 0;
  if (searchMetadata) {
    const regionKeywords = searchMetadata.region_keywords || [];
    const varietalKeywords = searchMetadata.varietal_keywords || [];
    
    for (const region of regionKeywords) {
      if (text.includes(region.toLowerCase())) {
        metaScore += 3;
        break;
      }
    }
    
    for (const varietal of varietalKeywords) {
      if (text.includes(varietal.toLowerCase())) {
        metaScore += 3;
        break;
      }
    }
  }
  
  // [6] 패널티
  let penalty = 0;
  const wineKeywords = ['wine', 'champagne', 'vineyard', 'winery', 'estate', 'vintage', 'bottle'];
  const hasWineKeyword = wineKeywords.some(keyword => text.includes(keyword));
  const hasProducerMatch = producerName && (title.includes(producerName.toLowerCase()) || snippet.includes(producerName.toLowerCase()));
  const hasCandidateMatch = nameScore > 0;
  
  if (!hasWineKeyword && !hasProducerMatch && !hasCandidateMatch) {
    penalty = -20;
  }
  
  // [7] 최종 점수
  const score = domainScore + nameScore + producerScore + vintageScore + metaScore + penalty;
  
  return score;
}

export const searchSingleCandidateV3 = async (req, res) => {
  try {
    const { candidate, original_ko, search_metadata } = req.body;
    
    if (!candidate) {
      return res.status(400).json({ 
        success: false, 
        message: 'candidate가 필요합니다.' 
      });
    }

    console.log(`[searchSingleCandidateV3] 검색 시작: "${candidate}"`);
    
    // SerpAPI 키
    const SERPAPI_KEY = process.env.SERPAPI_KEY || process.env.SERPAPI_API_KEY || 'a20c27f0143d0b0b5c6b23f94e4cc6c4a6a59edc9346a03ab8f090b76834a47a';
    
    // 검색 쿼리 구성 (search_metadata가 있으면 사용, 없으면 기본 쿼리)
    const searchQuery = search_metadata 
      ? buildWineQueryWithMetadata(search_metadata, candidate)
      : buildWineQuery(candidate, false);
    
    console.log(`[searchSingleCandidateV3] SerpAPI 요청 쿼리: ${searchQuery}`);
    const startTime = Date.now();
    
    // SerpAPI 호출 (일반 검색 결과만, 뉴스/쇼핑 등 제외)
    const serpApiUrl = new URL('https://serpapi.com/search.json');
    serpApiUrl.searchParams.set('engine', 'google');
    serpApiUrl.searchParams.set('q', searchQuery);
    serpApiUrl.searchParams.set('num', '20'); // 결과 수 증가 (기본 10 -> 20)
    serpApiUrl.searchParams.set('hl', 'en'); // 언어: 영어
    serpApiUrl.searchParams.set('gl', 'us'); // 국가: 미국
    serpApiUrl.searchParams.set('google_domain', 'google.com');
    serpApiUrl.searchParams.set('device', 'desktop'); // 데스크톱 결과
    serpApiUrl.searchParams.set('safe', 'active'); // 안전 검색 활성화
    // 뉴스 제외: tbs 파라미터로 뉴스 필터 제거
    serpApiUrl.searchParams.set('tbs', 'li:1'); // 일반 웹 검색만 (뉴스 제외)
    serpApiUrl.searchParams.set('api_key', SERPAPI_KEY);
    
    // 페이로드 로그 출력
    const payload = {
      url: serpApiUrl.toString().replace(/api_key=[^&]+/, 'api_key=***'),
      params: {
        engine: 'google',
        q: searchQuery,
        num: '20',
        hl: 'en',
        gl: 'us',
        google_domain: 'google.com',
        device: 'desktop',
        safe: 'active',
        tbs: 'li:1',
        api_key: '***'
      }
    };
    console.log(`[searchSingleCandidateV3] SerpAPI 페이로드:`, JSON.stringify(payload, null, 2));
    
    const response = await fetch(serpApiUrl.toString(), {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    });
    
    const elapsedTime = Date.now() - startTime;
    console.log(`[searchSingleCandidateV3] SerpAPI 응답 수신 (${elapsedTime}ms) - Status: ${response.status}`);

    if (!response.ok) {
      const errorText = await response.text().catch(() => '');
      const errorPreview = errorText.length > 300 ? errorText.substring(0, 300) + '...' : errorText;
      console.error(`[searchSingleCandidateV3] SerpAPI 오류 (${response.status}):`, errorPreview);
      return res.status(response.status).json({
        success: false,
        message: `SerpAPI 오류: ${response.status}`,
        error: errorPreview
      });
    }

    const serpData = await response.json();
    
    // 응답 전체 로그 출력
    const responseString = JSON.stringify(serpData, null, 2);
    const responseLength = responseString.length;
    console.log(`[searchSingleCandidateV3] SerpAPI 응답 전체 (${responseLength}자):`);
    console.log(responseString);
    
    // 요약 정보도 함께 출력
    console.log(`[searchSingleCandidateV3] SerpAPI 응답 요약:`, {
      organic_results: serpData.organic_results?.length || 0,
      total_results: serpData.search_information?.total_results || 0,
      knowledge_graph: !!serpData.knowledge_graph,
      answer_box: !!serpData.answer_box,
      related_questions: serpData.related_questions?.length || 0,
      shopping_results: serpData.shopping_results?.length || 0,
      all_keys: Object.keys(serpData)
    });
    
    console.log(`[searchSingleCandidateV3] SerpAPI 데이터 수신:`, {
      organic_results: serpData.organic_results?.length || 0,
      total_results: serpData.search_information?.total_results || 0,
      knowledge_graph: !!serpData.knowledge_graph,
      answer_box: !!serpData.answer_box,
      related_questions: serpData.related_questions?.length || 0,
      shopping_results: serpData.shopping_results?.length || 0
      // 뉴스, 이미지, 지역 결과는 제외 (organic_results와 shopping_results 사용)
    });
    
    // 전체 응답 구조 로그 (디버깅용)
    console.log(`[searchSingleCandidateV3] SerpAPI 응답 전체 키:`, Object.keys(serpData));
    
    // SerpAPI 결과를 직접 카드로 변환 (organic_results + shopping_results)
    const organicResults = serpData.organic_results || [];
    const shoppingResults = serpData.shopping_results || [];
    
    // 쇼핑 결과를 organic_results 형식으로 변환
    const convertedShoppingResults = shoppingResults.map((item, index) => ({
      position: (organicResults.length || 0) + index + 1,
      title: item.title || item.product_title || '',
      link: item.link || item.product_link || '',
      displayed_link: item.displayed_link || '',
      snippet: item.snippet || item.product_description || '',
      thumbnail: item.thumbnail || item.product_thumbnail || null,
      price: item.price || null,
      rich_snippet: item.rich_snippet || null,
      date: null
    }));
    
    // organic_results와 shopping_results 합치기
    const allResults = [...organicResults, ...convertedShoppingResults];
    console.log(`[searchSingleCandidateV3] 검색 결과 수: ${allResults.length}개 (organic: ${organicResults.length}, shopping: ${shoppingResults.length})`);
    
    // 첫 번째 결과 구조 확인 (디버깅용)
    if (allResults.length > 0) {
      const firstResult = allResults[0];
      console.log(`[searchSingleCandidateV3] 첫 번째 결과 구조:`, {
        position: firstResult.position,
        title: firstResult.title,
        link: firstResult.link,
        displayed_link: firstResult.displayed_link,
        thumbnail: firstResult.thumbnail,
        thumbnail_exists: !!firstResult.thumbnail,
        snippet: firstResult.snippet?.substring(0, 100),
        date: firstResult.date,
        rich_snippet: !!firstResult.rich_snippet,
        all_keys: Object.keys(firstResult)
      });
    }
    
    // Knowledge Graph 정보 확인
    if (serpData.knowledge_graph) {
      console.log(`[searchSingleCandidateV3] Knowledge Graph 정보:`, {
        title: serpData.knowledge_graph.title,
        type: serpData.knowledge_graph.type,
        description: serpData.knowledge_graph.description?.substring(0, 100),
        image: serpData.knowledge_graph.image,
        source: serpData.knowledge_graph.source
      });
    }
    
    // 컨텍스트 정보 추출 (점수 계산용)
    const producerName = extractProducerName(candidate, search_metadata);
    const cuvee = extractCuvee(candidate);
    const vintage = search_metadata?.vintage_keywords?.[0] || '';
    
    const context = {
      candidate,
      searchMetadata: search_metadata,
      producerName,
      cuvee,
      vintage
    };
    
    // 카드 결과 변환 및 점수 계산
    const cardResultsWithScore = allResults.map((result, index) => {
      // 도메인 추출
      let domain = null;
      try {
        if (result.link) {
          domain = new URL(result.link).hostname.replace('www.', '');
        } else if (result.displayed_link) {
          domain = result.displayed_link.replace('www.', '').split(' ›')[0];
        }
      } catch (e) {
        // URL 파싱 실패
      }
      
      const siteName = domain ? domain.split('.')[0] : 'Unknown';
      
      // 가격 정보 추출 시도 (snippet에서)
      let priceRange = null;
      if (result.snippet) {
        const priceMatch = result.snippet.match(/(?:US\$|AU\$|€|£|¥|KRW|원)\s*[\d,]+(?:\.\d+)?(?:\s*-\s*(?:US\$|AU\$|€|£|¥|KRW|원)?\s*[\d,]+(?:\.\d+)?)?/);
        if (priceMatch) {
          priceRange = priceMatch[0].trim();
        }
      }
      
      // Rich Snippet에서 가격 정보 추출
      if (!priceRange && result.rich_snippet?.top?.price) {
        priceRange = result.rich_snippet.top.price;
      }
      
      const thumbnailUrl = result.thumbnail || result.thumbnail_url || result.rich_snippet?.top?.thumbnail || null;
      
      // 위치 기반 관련성 점수 계산 (position이 낮을수록 관련성 높음)
      // position 1-3: 높음, 4-10: 중간, 11+: 낮음
      let relevanceScore = 0.5;
      let matchConfidence = 'medium';
      if (result.position) {
        if (result.position <= 3) {
          relevanceScore = 0.9;
          matchConfidence = 'high';
        } else if (result.position <= 10) {
          relevanceScore = 0.7;
          matchConfidence = 'medium';
        } else {
          relevanceScore = 0.5;
          matchConfidence = 'low';
        }
      }
      
      // 썸네일이 없으면 로그 출력 (처음 3개만)
      if (!thumbnailUrl && index < 3) {
        console.log(`[searchSingleCandidateV3] 결과 ${index + 1} 썸네일 없음:`, {
          title: result.title,
          position: result.position,
          available_fields: Object.keys(result).filter(k => k.toLowerCase().includes('image') || k.toLowerCase().includes('thumb') || k.toLowerCase().includes('img'))
        });
      }
      
      // wine_name 정리: 플레이스홀더 제거 및 정리
      let wineName = result.title || candidate;
      // [YEAR], [VINTAGE] 같은 플레이스홀더 제거
      wineName = wineName.replace(/\[.*?\]/g, '').trim();
      // 연속된 공백 정리
      wineName = wineName.replace(/\s+/g, ' ');
      
      // 점수 계산
      const score = computeScore({
        title: result.title,
        snippet: result.snippet,
        url: result.link
      }, context);
      
      return {
        candidate: candidate,
        wine_name: wineName,
        thumbnail_url: thumbnailUrl,
        url: result.link || null,
        domain: domain || null,
        price_range: priceRange || null,
        description: result.snippet || null,
        date: result.date || null,
        position: result.position || null,
        sources: result.link ? [{
          site_name: siteName.charAt(0).toUpperCase() + siteName.slice(1),
          url: result.link,
          image_url: thumbnailUrl
        }] : [],
        rating: null,
        region: null,
        grape_varieties: [],
        winery: null,
        vintage: null,
        relevance_score: relevanceScore,
        match_confidence: matchConfidence,
        hasTrustedSite: true,
        rich_snippet: result.rich_snippet || null,
        score: score // 점수 추가
      };
    });
    
    // 점수 기준으로 정렬 (내림차순)
    cardResultsWithScore.sort((a, b) => (b.score || 0) - (a.score || 0));
    
    const cardResults = cardResultsWithScore;
    
    console.log(`[searchSingleCandidateV3] 변환된 카드 수: ${cardResults.length}개`);
    console.log(`[searchSingleCandidateV3] 점수 분포:`, cardResults.slice(0, 5).map(c => ({
      wine_name: c.wine_name?.substring(0, 30),
      score: c.score,
      domain: c.domain
    })));

    // 첫 번째 결과를 기본 결과로 사용 (하위 호환성)
    const firstCard = cardResults[0] || {};
    
    const result = {
      candidate,
      wine_name: firstCard.wine_name || candidate,
      thumbnail_url: firstCard.thumbnail_url || null,
      sources: cardResults.map(card => card.sources[0]).filter(Boolean),
      rating: null,
      price_range: firstCard.price_range || null,
      description: firstCard.description || null,
      region: null,
      grape_varieties: [],
      winery: null,
      vintage: null,
      relevance_score: 0.5,
      match_confidence: 'medium',
      hasTrustedSite: cardResults.length > 0,
      // 카드 목록을 위한 추가 필드
      cards: cardResults
    };

    console.log(`[searchSingleCandidateV3] 검색 완료:`, {
      wine_name: result.wine_name,
      sources_count: result.sources?.length || 0
    });

    res.json({
      success: true,
      result
    });
  } catch (err) {
    console.error('[searchSingleCandidateV3] 검색 실패:', err);
    res.status(500).json({ 
      success: false, 
      message: err.message || '서버 오류' 
    });
  }
};

/**
 * SerpAPI 결과를 정리된 텍스트로 변환
 */
function formatSerpApiResults(serpData) {
  const results = [];
  const organicResults = serpData.organic_results || [];
  
  organicResults.forEach((result, index) => {
    let domain = 'N/A';
    try {
      if (result.link) {
        domain = new URL(result.link).hostname.replace('www.', '');
      } else if (result.displayed_link) {
        domain = result.displayed_link.replace('www.', '').split(' ›')[0];
      }
    } catch (e) {
      // URL 파싱 실패
    }
    
    const formatted = `Result ${index + 1}:
Title: ${result.title || 'N/A'}
URL: ${result.link || 'N/A'}
Domain: ${domain}
Image: ${result.thumbnail || 'N/A'}
Description: ${result.snippet || 'N/A'}
---`;
    results.push(formatted);
  });
  
  return results.join('\n\n');
}

/**
 * 구글 검색 결과 HTML 정리 - 핵심 정보만 추출 (모든 태그 제거)
 */
function cleanGoogleSearchHtml(html) {
  // 검색 결과 블록만 추출 (div.g 또는 유사한 구조)
  const resultBlocks = [];
  
  // 여러 패턴 시도
  // 패턴 1: div.g 클래스
  let resultBlockPattern = /<div[^>]*class="[^"]*g[^"]*"[^>]*>([\s\S]*?)<\/div>\s*(?=<div[^>]*class="[^"]*g[^"]*"|$)/g;
  let blockMatch;
  let matchCount = 0;
  
  while ((blockMatch = resultBlockPattern.exec(html)) !== null && resultBlocks.length < 20) {
    matchCount++;
    const blockHtml = blockMatch[1];
    
    // 각 블록에서 핵심 정보만 추출
    const extracted = {
      title: '',
      url: '',
      snippet: '',
      image: ''
    };
    
    // 제목 추출 (모든 태그 제거)
    const titleMatch = blockHtml.match(/<h3[^>]*>(.*?)<\/h3>/s);
    if (titleMatch) {
      extracted.title = removeAllTags(titleMatch[1]);
    }
    
    // URL 추출
    const urlMatch = blockHtml.match(/href=["']([^"']+)["']/);
    if (urlMatch) {
      const rawUrl = urlMatch[1];
      if (rawUrl.startsWith('/url?q=')) {
        try {
          extracted.url = decodeURIComponent(rawUrl.substring(7).split('&')[0]);
        } catch (e) {
          extracted.url = rawUrl;
        }
      } else if (rawUrl.startsWith('http')) {
        extracted.url = rawUrl;
      }
    }
    
    // 스니펫 추출 (모든 태그 제거)
    const snippetMatch = blockHtml.match(/<div[^>]*class="[^"]*VwiC3b[^"]*"[^>]*>(.*?)<\/div>/s) ||
                        blockHtml.match(/<span[^>]*class="[^"]*aCOpRe[^"]*"[^>]*>(.*?)<\/span>/s);
    if (snippetMatch) {
      extracted.snippet = removeAllTags(snippetMatch[1]);
    }
    
    // 이미지 추출
    const imgMatch = blockHtml.match(/<img[^>]*src=["']([^"']+)["']/);
    if (imgMatch && !imgMatch[1].includes('googleusercontent.com')) {
      extracted.image = imgMatch[1];
    }
    
    // 유효한 정보가 있으면 추가
    if (extracted.title || extracted.url) {
      resultBlocks.push(extracted);
    }
  }
  
  // 패턴 1로 매칭이 안 되면 다른 패턴 시도
  if (resultBlocks.length === 0) {
    console.log(`[cleanGoogleSearchHtml] 패턴 1 매칭 실패 (${matchCount}개 매칭), 다른 패턴 시도`);
    
    // 패턴 2: data-ved 속성이 있는 div
    resultBlockPattern = /<div[^>]*data-ved="[^"]*"[^>]*>([\s\S]*?)<\/div>/g;
    matchCount = 0;
    
    while ((blockMatch = resultBlockPattern.exec(html)) !== null && resultBlocks.length < 20) {
      matchCount++;
      const blockHtml = blockMatch[1];
      
      const extracted = {
        title: '',
        url: '',
        snippet: '',
        image: ''
      };
      
      // 제목 추출
      const titleMatch = blockHtml.match(/<h3[^>]*>(.*?)<\/h3>/s);
      if (titleMatch) {
        extracted.title = removeAllTags(titleMatch[1]);
      }
      
      // URL 추출
      const urlMatch = blockHtml.match(/href=["']([^"']+)["']/);
      if (urlMatch) {
        const rawUrl = urlMatch[1];
        if (rawUrl.startsWith('/url?q=')) {
          try {
            extracted.url = decodeURIComponent(rawUrl.substring(7).split('&')[0]);
          } catch (e) {
            extracted.url = rawUrl;
          }
        } else if (rawUrl.startsWith('http')) {
          extracted.url = rawUrl;
        }
      }
      
      // 스니펫 추출
      const snippetMatch = blockHtml.match(/<div[^>]*class="[^"]*VwiC3b[^"]*"[^>]*>(.*?)<\/div>/s) ||
                          blockHtml.match(/<span[^>]*class="[^"]*aCOpRe[^"]*"[^>]*>(.*?)<\/span>/s);
      if (snippetMatch) {
        extracted.snippet = removeAllTags(snippetMatch[1]);
      }
      
      if (extracted.title || extracted.url) {
        resultBlocks.push(extracted);
      }
    }
    
    console.log(`[cleanGoogleSearchHtml] 패턴 2 매칭 결과: ${matchCount}개 매칭, ${resultBlocks.length}개 결과 추출`);
  } else {
    console.log(`[cleanGoogleSearchHtml] 패턴 1 매칭 성공: ${matchCount}개 매칭, ${resultBlocks.length}개 결과 추출`);
  }
  
  // 구조화된 텍스트로 변환 (태그 없이 순수 텍스트만)
  const structuredText = resultBlocks.map((block, index) => {
    let domain = 'N/A';
    try {
      if (block.url && (block.url.startsWith('http://') || block.url.startsWith('https://'))) {
        domain = new URL(block.url).hostname.replace('www.', '');
      }
    } catch (e) {
      // URL 파싱 실패
    }
    
    return `Result ${index + 1}:
Title: ${block.title || 'N/A'}
URL: ${block.url || 'N/A'}
Domain: ${domain}
Image: ${block.image || 'N/A'}
Description: ${block.snippet || 'N/A'}
---`;
  }).join('\n\n');
  
  return structuredText;
}

/**
 * 모든 HTML 태그 제거 (재귀적으로 처리)
 */
function removeAllTags(html) {
  if (!html) return '';
  
  // HTML 엔티티 디코딩
  let cleaned = html
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'");
  
  // 모든 HTML 태그 제거 (재귀적으로)
  let previousLength = 0;
  while (cleaned.length !== previousLength) {
    previousLength = cleaned.length;
    cleaned = cleaned.replace(/<[^>]+>/g, '');
  }
  
  // 연속된 공백 정리
  cleaned = cleaned
    .replace(/\s+/g, ' ')
    .trim();
  
  return cleaned;
}

/**
 * 구글 검색 결과 HTML에서 구조화된 정보 추출 (기존 함수 - 사용 안 함)
 */
function extractGoogleSearchResults(html) {
  const results = [];
  
  // 구글 검색 결과는 일반적으로 div.g 또는 div[data-ved]로 시작
  // 각 결과는 다음과 같은 구조를 가짐:
  // - 제목: h3.LC20lb 또는 h3 태그
  // - URL: div.yuRUbf > a 또는 직접 a 태그
  // - 스니펫: div.VwiC3b 또는 span 태그
  
  // 검색 결과 블록 찾기 (div.g 또는 유사한 구조)
  const resultBlockPattern = /<div[^>]*class="[^"]*g[^"]*"[^>]*>([\s\S]*?)<\/div>\s*(?=<div[^>]*class="[^"]*g[^"]*"|$)/g;
  
  let blockMatch;
  while ((blockMatch = resultBlockPattern.exec(html)) !== null) {
    const blockHtml = blockMatch[1];
    
    // 제목 추출 (h3 태그)
    const titleMatch = blockHtml.match(/<h3[^>]*class="[^"]*LC20lb[^"]*"[^>]*>(.*?)<\/h3>/s);
    const title = titleMatch ? cleanHtml(titleMatch[1]) : null;
    
    // URL 추출
    let url = null;
    
    // 방법 1: div.yuRUbf > a 태그에서 href 추출
    const yuRUbfMatch = blockHtml.match(/<div[^>]*class="[^"]*yuRUbf[^"]*"[^>]*>[\s\S]*?<a[^>]*href=["']([^"']+)["']/);
    if (yuRUbfMatch) {
      url = decodeGoogleUrl(yuRUbfMatch[1]);
    }
    
    // 방법 2: 직접 a 태그의 href에서 추출 (yuRUbf가 없는 경우)
    if (!url) {
      const directLinkMatch = blockHtml.match(/<a[^>]*href=["']([^"']+)["'][^>]*>[\s\S]*?<h3/s);
      if (directLinkMatch) {
        url = decodeGoogleUrl(directLinkMatch[1]);
      }
    }
    
    // 방법 3: /url?q= 패턴에서 추출
    if (!url) {
      const urlQMatch = blockHtml.match(/\/url\?q=([^&"'>]+)/);
      if (urlQMatch) {
        url = decodeGoogleUrl(urlQMatch[1]);
      }
    }
    
    // 스니펫 추출
    let snippet = null;
    const snippetMatch = blockHtml.match(/<div[^>]*class="[^"]*VwiC3b[^"]*"[^>]*>(.*?)<\/div>/s) ||
                        blockHtml.match(/<span[^>]*class="[^"]*aCOpRe[^"]*"[^>]*>(.*?)<\/span>/s);
    if (snippetMatch) {
      snippet = cleanHtml(snippetMatch[1]);
    }
    
    // 이미지 썸네일 추출
    let thumbnail = null;
    // 방법 1: img 태그에서 src 추출
    const imgMatch = blockHtml.match(/<img[^>]*src=["']([^"']+)["']/);
    if (imgMatch && imgMatch[1]) {
      const imgSrc = imgMatch[1];
      // 구글 이미지 프록시가 아닌 실제 이미지 URL만 사용
      if (!imgSrc.includes('googleusercontent.com') && 
          !imgSrc.includes('gstatic.com') &&
          (imgSrc.startsWith('http://') || imgSrc.startsWith('https://'))) {
        thumbnail = imgSrc;
      }
    }
    
    // 가격 정보 추출 (스니펫에서)
    let price = null;
    if (snippet) {
      const priceMatch = snippet.match(/(?:US\$|AU\$|€|£|¥|KRW|원)\s*[\d,]+(?:\.\d+)?(?:\s*-\s*(?:US\$|AU\$|€|£|¥|KRW|원)?\s*[\d,]+(?:\.\d+)?)?/);
      if (priceMatch) {
        price = priceMatch[0].trim();
      }
    }
    
    // 도메인 추출
    let domain = null;
    if (url) {
      try {
        domain = new URL(url).hostname.replace('www.', '');
      } catch (e) {
        // URL 파싱 실패
      }
    }
    
    // 유효한 결과만 추가
    if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
      // 구글 내부 링크 제외
      if (!url.includes('google.com') && !url.includes('googleusercontent.com')) {
        results.push({
          title: title || '',
          url: url,
          domain: domain || '',
          thumbnail: thumbnail || null,
          price: price || null,
          description: snippet || ''
        });
      }
    }
  }
  
  // 위 방법으로 결과가 없으면 간단한 패턴으로 재시도
  if (results.length === 0) {
    // /url?q= 패턴으로 URL 추출
    const redirectPattern = /\/url\?q=([^&"'>]+)/g;
    let match;
    const seenUrls = new Set();
    
    while ((match = redirectPattern.exec(html)) !== null && results.length < 20) {
      try {
        const decodedUrl = decodeURIComponent(match[1]);
        if (decodedUrl.startsWith('http://') || decodedUrl.startsWith('https://')) {
          if (!decodedUrl.includes('google.com') && !seenUrls.has(decodedUrl)) {
            seenUrls.add(decodedUrl);
            let domain = '';
            try {
              domain = new URL(decodedUrl).hostname;
            } catch (e) {}
            
            results.push({
              title: '',
              url: decodedUrl,
              domain: domain,
              snippet: ''
            });
          }
        }
      } catch (e) {
        // URL 디코딩 실패 무시
      }
    }
  }
  
  return results;
}

/**
 * HTML 태그 제거 및 텍스트 정리
 */
function cleanHtml(html) {
  if (!html) return '';
  return html
    .replace(/<[^>]+>/g, '') // HTML 태그 제거
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * 구글 URL 디코딩 (/url?q= 형태 처리)
 */
function decodeGoogleUrl(url) {
  if (!url) return null;
  
  // /url?q= 형태인 경우
  if (url.startsWith('/url?q=')) {
    try {
      const decoded = decodeURIComponent(url.substring(7).split('&')[0]);
      if (decoded.startsWith('http://') || decoded.startsWith('https://')) {
        return decoded;
      }
    } catch (e) {
      // 디코딩 실패
    }
  }
  
  // 이미 완전한 URL인 경우
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  
  // 상대 경로인 경우
  if (url.startsWith('/')) {
    return 'https://www.google.com' + url;
  }
  
  return url;
}

/**
 * 단일 Candidate를 Perplexity API로 검색
 * POST /external_wine_search/search_single_candidate
 */
export const searchSingleCandidate = async (req, res) => {
  try {
    const { candidate, original_ko } = req.body;
    
    if (!candidate) {
      return res.status(400).json({ 
        success: false, 
        message: 'candidate가 필요합니다.' 
      });
    }

    // Perplexity API 키
    const perplexityApiKey = process.env.PERPLEXITY_API_KEY;
    
    console.log(`[searchSingleCandidate] 검색 시작: "${candidate}"`);
    
    const prompt = `You are an expert wine data extractor and must accurately identify wines from the given candidate English wine names.  

For each candidate name, perform multi-site search and return a structured JSON object strictly following the required schema.

## TASK

1. Use the candidate wine names exactly as provided.  

2. Search across as many reputable global wine sources as possible, including but not limited to:

   - Vivino

   - Wine-Searcher

   - CellarTracker

   - Wine.com

   - Decanter

   - Vinous

   - JamesSuckling

   - Robert Parker (Wine Advocate)

   - The Wine Collective / local retailers

   - Winery official website

3. Return information ONLY if the match is strong and the bottle corresponds to the real wine name.

4. If multiple possible matches exist, choose the one with the highest relevance score (market frequency + site consensus).

5. Extract COMPREHENSIVE DETAILED INFORMATION for each wine, including:
   - Exact official wine name (full name with winery, cuvée, vintage)
   - High-quality thumbnail image URL (prefer retailer sites)
   - ALL available source URLs (Vivino, Wine-Searcher, CellarTracker, etc.)
   - Rating information (score, max score, source)
   - Price range (if available from multiple retailers)
   - Detailed description (tasting notes, wine characteristics)
   - Region/appellation information
   - Grape varieties (complete list)
   - Winery/producer name
   - Vintage year
   - Relevance score and match confidence

6. Extract ALL available URLs for the wine from the found sites. Each URL must be a direct link to the wine's product detail page.

7. The final response must strictly follow the JSON schema below with ALL fields populated when available.

## MATCHING RULES

- The name must match vintage, grape, region, and winery as closely as possible.

- Normalize variations such as "&", "and", accents, spacing differences.

- If a site returns multiple possible bottles, choose the closest match and return its URL.

- Prefer retailer sites for thumbnail_url (Wine.com, NakedWines, Wine-Searcher listings, European retailers).

- If an image is missing on some sites, set image_url to null.

- Extract ALL available detailed information from each source - do not skip any fields if the information is available.

- For description, include comprehensive tasting notes, wine characteristics, and production details when available.

- For grape_varieties, list ALL grape varieties used in the wine, including percentages if available.

- For region, include the full appellation/region name (e.g., "Bordeaux, France" not just "Bordeaux").

## RATING RULES

- If multiple rating sources exist, choose either the most reputable (Suckling/WA/Vinous)  

  OR the most recent one.

- If no rating is available, set rating to null.

## PRICE RULES

- Collect multiple prices if possible; convert ranges into a readable "price_range".

- Keep currency as-is from the site (do not convert).

## OUTPUT FORMAT (STRICT)

For each input wine candidate, return a list of objects in the following format:

[

  {

    "wine_name": "exact official wine name",

    "thumbnail_url": "URL or null",
    "sources": [

      {

        "site_name": "Vivino",

        "url": "https://...",

        "image_url": "https://..."

      }

    ],

    "rating": {

      "score": 4.5,

      "max_score": 5.0,

      "source": "Vivino"

    },

    "price_range": "€40-60",

    "description": "Short, factual bottle description.",

    "region": "region name",

    "grape_varieties": ["grape1", "grape2"],

    "winery": "winery name",

    "vintage": "2018",

    "relevance_score": 0.0-1.0,

    "match_confidence": "high | medium | low"

  }

]

## INPUT CANDIDATES

${candidate}
${original_ko ? `Original Korean name: ${original_ko}` : ''}

## IMPORTANT

- Return JSON only. No commentary. No markdown.  

- If a wine is not found, return an empty object \`{}\` for that candidate.

- CRITICAL: Extract COMPREHENSIVE and DETAILED information for each wine. Do not leave fields empty if the information is available from the sources.

- Include ALL available details: full wine name, multiple source URLs, ratings, prices, detailed descriptions, complete grape variety lists, full region names, winery information, and vintage.

- The more detailed and complete the information, the better. Prioritize accuracy and completeness over speed.`;

    // Perplexity API 호출
    const requestBody = {
      model: 'sonar',
      messages: [
        {
          role: 'system',
          content: 'You are an expert wine data extractor. Search multiple reputable wine sources and return structured JSON data. Return JSON only, no markdown or commentary.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.2,
      max_tokens: 2000
    };
    
    console.log(`[searchSingleCandidate] Perplexity API 호출 시작`);
    const startTime = Date.now();
    
    const perplexityResponse = await fetch('https://api.perplexity.ai/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${perplexityApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });
    
    const elapsedTime = Date.now() - startTime;
    console.log(`[searchSingleCandidate] Perplexity API 응답 수신 (${elapsedTime}ms) - Status: ${perplexityResponse.status}`);

    if (!perplexityResponse.ok) {
      const errorText = await perplexityResponse.text().catch(() => '');
      const errorPreview = errorText.length > 300 ? errorText.substring(0, 300) + '...' : errorText;
      console.error(`[searchSingleCandidate] Perplexity API 오류 (${perplexityResponse.status}):`, errorPreview);
      return res.status(perplexityResponse.status).json({
        success: false,
        message: `Perplexity API 오류: ${perplexityResponse.status}`,
        error: errorPreview
      });
    }

    const perplexityData = await perplexityResponse.json();
    const responseText = perplexityData.choices?.[0]?.message?.content;
    
    // 응답 로그 (너무 길면 자르기)
    const responsePreview = responseText ? 
      (responseText.length > 500 ? responseText.substring(0, 500) + '...' : responseText) : 
      'null';
    console.log(`[searchSingleCandidate] Perplexity 응답 (${responseText?.length || 0}자):`, responsePreview);
    
    if (!responseText) {
      console.log(`[searchSingleCandidate] 응답 없음`);
      return res.json({
        success: false,
        candidate,
        error: '응답 없음'
      });
    }

    // JSON 파싱
    let wineData = {};
    try {
      let jsonText = responseText.trim();
      
      // 코드 블록 제거
      if (jsonText.includes('```')) {
        const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
        if (jsonBlockMatch && jsonBlockMatch[1]) {
          jsonText = jsonBlockMatch[1].trim();
        }
      }
      
      // JSON 파싱 시도
      let parsed = JSON.parse(jsonText);
      
      // OpenAI의 response_format이 json_object일 때는 객체를 반환할 수 있음
      // 배열이거나 객체의 배열 속성이 있는지 확인
      if (Array.isArray(parsed)) {
        // 배열인 경우 첫 번째 요소 사용
        wineData = parsed.length > 0 ? parsed[0] : {};
      } else if (parsed.wines && Array.isArray(parsed.wines)) {
        // { wines: [...] } 형태인 경우
        wineData = parsed.wines.length > 0 ? parsed.wines[0] : {};
      } else if (typeof parsed === 'object' && Object.keys(parsed).length > 0) {
        // 단일 객체인 경우 그대로 사용
        wineData = parsed;
      } else {
        throw new Error('유효한 와인 데이터를 찾을 수 없습니다.');
      }
      
      // 빈 객체인 경우 처리
      if (!wineData || Object.keys(wineData).length === 0) {
        console.log(`[searchSingleCandidate] 와인을 찾지 못함: "${candidate}"`);
        return res.json({
          success: false,
          candidate,
          error: '와인을 찾지 못했습니다.'
        });
      }
    } catch (parseError) {
      console.error(`[searchSingleCandidate] JSON 파싱 실패:`, parseError.message);
      console.error(`[searchSingleCandidate] 응답 텍스트 (처음 500자):`, responseText.substring(0, 500));
      
      return res.json({
        success: false,
        candidate,
        error: `JSON 파싱 실패: ${parseError.message}`
      });
    }

    // 공신력 있는 사이트 목록
    const trustedSites = [
      'vivino',
      'wine-searcher',
      'winesearcher',
      'cellartracker',
      'wine.com',
      'winespectator',
      'decanter',
      'robertparker',
      'jancisrobinson',
      'wineenthusiast'
    ];

    // 공신력 있는 사이트가 sources에 있는지 확인
    const hasTrustedSite = wineData.sources?.some(source => {
      const siteName = (source.site_name || '').toLowerCase();
      return trustedSites.some(trusted => siteName.includes(trusted));
    });

    const result = {
      candidate,
      wine_name: wineData.wine_name || candidate,
      thumbnail_url: wineData.thumbnail_url || null,
      sources: wineData.sources || [],
      rating: wineData.rating || null,
      price_range: wineData.price_range || null,
      description: wineData.description || null,
      region: wineData.region || null,
      grape_varieties: wineData.grape_varieties || [],
      winery: wineData.winery || null,
      vintage: wineData.vintage || null,
      relevance_score: wineData.relevance_score || 0.5,
      match_confidence: wineData.match_confidence || 'medium',
      hasTrustedSite
    };

    console.log(`[searchSingleCandidate] 검색 완료:`, {
      wine_name: result.wine_name,
      relevance_score: result.relevance_score,
      match_confidence: result.match_confidence,
      hasTrustedSite: result.hasTrustedSite,
      sources_count: result.sources?.length || 0
    });

    res.json({
      success: true,
      result
    });
  } catch (err) {
    console.error('[searchSingleCandidate] 검색 실패:', err);
    res.status(500).json({ 
      success: false, 
      message: err.message || '서버 오류' 
    });
  }
};

/**
 * Candidate들을 하나의 프롬프트로 Perplexity API 검색 (Ver2)
 * POST /external_wine_search/search_candidates_with_perplexity_v2
 */
export const searchCandidatesWithPerplexityV2 = async (req, res) => {
  try {
    const { candidates, original_ko } = req.body;
    
    if (!candidates || !Array.isArray(candidates) || candidates.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'candidates 배열이 필요합니다.' 
      });
    }

    const perplexityApiKey = process.env.PERPLEXITY_API_KEY;
    const geminiApiKey = process.env.GEMINI_API_KEY;
    const openaiApiKey = process.env.OPENAI_API_KEY;
    
    console.log(`[searchCandidatesWithPerplexityV2] 시작 - candidates: ${candidates.length}개, original_ko: ${original_ko || 'N/A'}`);
    
    // 검색어: original_ko가 있으면 그것을 우선 사용, 없으면 candidates 사용
    const searchQuery = original_ko || candidates.join(', ');
    const candidatesList = candidates.map((c, i) => `${i + 1}. ${c}`).join('\n');
    
    const prompt = `다음 와인 이름들로 검색하여 각 와인에 대한 정보를 JSON 배열 형식으로 제공해주세요.

대표 와인명: ${searchQuery}
와인 이름 목록:
${candidatesList}
${original_ko ? `원본 한국어 이름: ${original_ko}` : ''}

**중요: 검색 우선순위**
1. **최우선**: Wine-Searcher (wine-searcher.com) - 와인 가격 비교, 상세 정보, 이미지
2. 기타 해외 와인 전문 사이트:
   - Wine.com
   - Wine Spectator (winespectator.com)
   - Decanter (decanter.com)
   - Robert Parker (robertparker.com)
   - Vivino (vivino.com)
   - CellarTracker (cellartracker.com)

각 와인에 대해 다음 정보를 포함한 JSON 배열을 반환해주세요:
[
  {
    "candidate": "원본 candidate 이름",
    "wine_name": "정확한 와인 이름",
    "thumbnail_url": "와인 썸네일 이미지 URL",
    "sources": [
      {
        "site_name": "사이트 이름",
        "url": "사이트 URL",
        "image_url": "해당 사이트의 와인 이미지 URL"
      }
    ],
    "rating": {
      "score": 4.5,
      "max_score": 5.0,
      "source": "평점 출처"
    },
    "price_range": "가격 범위 (예: $50-80)",
    "description": "와인 설명",
    "region": "생산 지역",
    "grape_varieties": ["포도 품종1", "포도 품종2"],
    "winery": "와이너리 이름",
    "vintage": "빈티지",
    "relevance_score": 0.95,
    "match_confidence": "high"
  }
]

중요:
- 각 candidate에 대해 하나의 객체를 반환하세요
- relevance_score는 검색된 와인이 입력된 이름과 얼마나 일치하는지 0.0-1.0 사이의 점수로 제공하세요
- match_confidence는 "high", "medium", "low" 중 하나로 제공하세요
- 실제 검색 결과를 기반으로 정확한 정보를 제공하세요
- 정보가 없는 경우 null 또는 빈 배열을 사용하세요
- JSON 배열만 반환하고 다른 텍스트는 포함하지 마세요`;

    // Perplexity, Gemini, ChatGPT 동시 호출
    console.log(`[searchCandidatesWithPerplexityV2] API 동시 호출 시작 (candidates: ${candidates.length}개)`);
    const startTime = Date.now();
    
    const [perplexityResult, geminiResult, openaiResult] = await Promise.allSettled([
      // Perplexity API 호출
      fetch('https://api.perplexity.ai/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${perplexityApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'sonar',
          messages: [
            {
              role: 'system',
              content: 'You are a helpful assistant that provides wine information in JSON array format.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.2,
          max_tokens: 4000
        }),
      }),
      // Gemini API 호출
      fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${geminiApiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 4000,
            topP: 0.8,
            topK: 40,
            candidateCount: 1,
          }
        }),
      }),
      // ChatGPT API 호출
      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'You are a helpful assistant that provides wine information in JSON array format. Return only valid JSON array, no markdown or code blocks.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.2,
          max_tokens: 4000
        }),
      })
    ]);

    const elapsedTime = Date.now() - startTime;
    console.log(`[searchCandidatesWithPerplexityV2] 모든 API 응답 수신 (${elapsedTime}ms)`);

    // 각 API 응답 파싱
    let allWinesArrays = [];

    // Perplexity 결과 처리
    if (perplexityResult.status === 'fulfilled' && perplexityResult.value.ok) {
      try {
        const perplexityData = await perplexityResult.value.json();
        const responseText = perplexityData.choices?.[0]?.message?.content;
        if (responseText) {
          let jsonText = responseText.trim();
          if (jsonText.includes('```')) {
            const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch && jsonBlockMatch[1]) {
              jsonText = jsonBlockMatch[1].trim();
            }
          }
          const parsed = JSON.parse(jsonText);
          const winesArray = Array.isArray(parsed) ? parsed : (parsed.wines ? parsed.wines : [parsed]);
          allWinesArrays.push(...winesArray.map(w => ({ ...w, source: 'perplexity' })));
          console.log(`[searchCandidatesWithPerplexityV2] Perplexity 파싱 완료 - ${winesArray.length}개`);
        }
      } catch (error) {
        console.error(`[searchCandidatesWithPerplexityV2] Perplexity 파싱 실패:`, error.message);
      }
    } else {
      console.warn(`[searchCandidatesWithPerplexityV2] Perplexity API 실패`);
    }

    // Gemini 결과 처리
    if (geminiResult.status === 'fulfilled' && geminiResult.value.ok) {
      try {
        const geminiData = await geminiResult.value.json();
        const responseText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text;
        if (responseText) {
          let jsonText = responseText.trim();
          if (jsonText.includes('```')) {
            const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch && jsonBlockMatch[1]) {
              jsonText = jsonBlockMatch[1].trim();
            }
          }
          const parsed = JSON.parse(jsonText);
          const winesArray = Array.isArray(parsed) ? parsed : (parsed.wines ? parsed.wines : [parsed]);
          allWinesArrays.push(...winesArray.map(w => ({ ...w, source: 'gemini' })));
          console.log(`[searchCandidatesWithPerplexityV2] Gemini 파싱 완료 - ${winesArray.length}개`);
        }
      } catch (error) {
        console.error(`[searchCandidatesWithPerplexityV2] Gemini 파싱 실패:`, error.message);
      }
    } else {
      console.warn(`[searchCandidatesWithPerplexityV2] Gemini API 실패`);
    }

    // ChatGPT 결과 처리
    if (openaiResult.status === 'fulfilled' && openaiResult.value.ok) {
      try {
        const openaiData = await openaiResult.value.json();
        const responseText = openaiData.choices?.[0]?.message?.content;
        if (responseText) {
          let jsonText = responseText.trim();
          if (jsonText.includes('```')) {
            const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch && jsonBlockMatch[1]) {
              jsonText = jsonBlockMatch[1].trim();
            }
          }
          const parsed = JSON.parse(jsonText);
          const winesArray = Array.isArray(parsed) ? parsed : (parsed.wines ? parsed.wines : [parsed]);
          allWinesArrays.push(...winesArray.map(w => ({ ...w, source: 'chatgpt' })));
          console.log(`[searchCandidatesWithPerplexityV2] ChatGPT 파싱 완료 - ${winesArray.length}개`);
        }
      } catch (error) {
        console.error(`[searchCandidatesWithPerplexityV2] ChatGPT 파싱 실패:`, error.message);
      }
    } else {
      console.warn(`[searchCandidatesWithPerplexityV2] ChatGPT API 실패`);
    }

    // 결과가 없으면 빈 배열 반환
    if (allWinesArrays.length === 0) {
      console.log(`[searchCandidatesWithPerplexityV2] 모든 API에서 결과 없음`);
      return res.json({
        success: true,
        results: [],
        total: 0,
        failed: candidates.length
      });
    }

    // candidate별로 그룹화하고 병합
    const winesMap = new Map();
    allWinesArrays.forEach(wine => {
      const candidate = wine.candidate || candidates[0] || '';
      const key = candidate.toLowerCase().trim();
      
      if (!winesMap.has(key)) {
        winesMap.set(key, {
          candidate,
          wine_name: wine.wine_name || candidate,
          thumbnail_url: wine.thumbnail_url || null,
          sources: wine.sources || [],
          rating: wine.rating || null,
          price_range: wine.price_range || null,
          description: wine.description || null,
          region: wine.region || null,
          grape_varieties: wine.grape_varieties || [],
          winery: wine.winery || null,
          vintage: wine.vintage || null,
          relevance_score: wine.relevance_score || 0.5,
          match_confidence: wine.match_confidence || 'medium',
          sources_list: [wine.source || 'unknown']
        });
      } else {
        const existing = winesMap.get(key);
        // sources 병합 (중복 제거)
        if (wine.sources && Array.isArray(wine.sources)) {
          const existingUrls = new Set(existing.sources.map(s => s.url));
          wine.sources.forEach(source => {
            if (!existingUrls.has(source.url)) {
              existing.sources.push(source);
            }
          });
        }
        // 더 높은 relevance_score 사용
        if (wine.relevance_score > existing.relevance_score) {
          existing.relevance_score = wine.relevance_score;
          existing.match_confidence = wine.match_confidence || existing.match_confidence;
        }
        // 누락된 정보 채우기
        if (!existing.thumbnail_url && wine.thumbnail_url) {
          existing.thumbnail_url = wine.thumbnail_url;
        }
        if (!existing.rating && wine.rating) {
          existing.rating = wine.rating;
        }
        if (!existing.description && wine.description) {
          existing.description = wine.description;
        }
        if (!existing.region && wine.region) {
          existing.region = wine.region;
        }
        if (!existing.winery && wine.winery) {
          existing.winery = wine.winery;
        }
        if (!existing.vintage && wine.vintage) {
          existing.vintage = wine.vintage;
        }
        if (!existing.price_range && wine.price_range) {
          existing.price_range = wine.price_range;
        }
        // grape_varieties 병합
        if (wine.grape_varieties && Array.isArray(wine.grape_varieties)) {
          const existingGrapes = new Set(existing.grape_varieties);
          wine.grape_varieties.forEach(grape => {
            if (!existingGrapes.has(grape)) {
              existing.grape_varieties.push(grape);
            }
          });
        }
        existing.sources_list.push(wine.source || 'unknown');
      }
    });

    const winesArray = Array.from(winesMap.values());
    console.log(`[searchCandidatesWithPerplexityV2] 병합 완료 - ${winesArray.length}개 와인 정보`);

    // 공신력 있는 사이트 목록
    const trustedSites = [
      'vivino',
      'wine-searcher',
      'winesearcher',
      'cellartracker',
      'wine.com',
      'winespectator',
      'decanter',
      'robertparker',
      'jancisrobinson',
      'wineenthusiast'
    ];

    // 각 와인 데이터를 정리하고 스코어링
    const processedResults = winesArray
      .map((wineData, index) => {
        // candidate 매칭 (candidate 필드가 없으면 candidates 배열의 인덱스로 매칭)
        const candidate = wineData.candidate || candidates[index] || '';
        
        // 공신력 있는 사이트가 sources에 있는지 확인
        const hasTrustedSite = wineData.sources?.some(source => {
          const siteName = (source.site_name || '').toLowerCase();
          return trustedSites.some(trusted => siteName.includes(trusted));
        });
        
        return {
          candidate,
          wine_name: wineData.wine_name || candidate,
          thumbnail_url: wineData.thumbnail_url || null,
          sources: wineData.sources || [],
          rating: wineData.rating || null,
          price_range: wineData.price_range || null,
          description: wineData.description || null,
          region: wineData.region || null,
          grape_varieties: wineData.grape_varieties || [],
          winery: wineData.winery || null,
          vintage: wineData.vintage || null,
          relevance_score: wineData.relevance_score || 0.5,
          match_confidence: wineData.match_confidence || 'medium',
          hasTrustedSite,
          originalIndex: index
        };
      })
      .sort((a, b) => {
        // 스코어링 로직:
        // 1. 공신력 있는 사이트 보너스 (50점)
        // 2. relevance_score (100점 만점)
        // 3. match_confidence (high: 10, medium: 5, low: 0)
        // 4. sources 수 (최대 10점)
        const scoreA = (a.hasTrustedSite ? 50 : 0) +
                      (a.relevance_score || 0) * 100 + 
                      (a.match_confidence === 'high' ? 10 : a.match_confidence === 'medium' ? 5 : 0) +
                      Math.min((a.sources?.length || 0), 10);
        const scoreB = (b.hasTrustedSite ? 50 : 0) +
                      (b.relevance_score || 0) * 100 + 
                      (b.match_confidence === 'high' ? 10 : b.match_confidence === 'medium' ? 5 : 0) +
                      Math.min((b.sources?.length || 0), 10);
        return scoreB - scoreA; // 내림차순 정렬
      });

    console.log(`[searchCandidatesWithPerplexityV2] 정렬 완료 - 최종 결과: ${processedResults.length}개`);
    if (processedResults.length > 0) {
      console.log(`[searchCandidatesWithPerplexityV2] 상위 3개 결과:`, processedResults.slice(0, 3).map(r => ({
        wine_name: r.wine_name,
        relevance_score: r.relevance_score,
        match_confidence: r.match_confidence,
        hasTrustedSite: r.hasTrustedSite,
        sources_count: r.sources?.length || 0
      })));
    }

    res.json({
      success: true,
      results: processedResults,
      total: processedResults.length,
      failed: candidates.length - processedResults.length
    });
  } catch (err) {
    console.error('[searchCandidatesWithPerplexityV2] 검색 실패:', err);
    res.status(500).json({ 
      success: false, 
      message: err.message || '서버 오류' 
    });
  }
};

